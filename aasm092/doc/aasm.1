.if \n(zZ=1 .ig zZ
.if \n(zY=1 .ig zY
.TH aasm 1 "2002 Dec" "aasm(1)"

.de }1
.ds ]X \&\\*(]B\\
.nr )E 0
.if !"\\$1"" .nr )I \\$1n
.}f
.ll \\n(LLu
.in \\n()Ru+\\n(INu+\\n()Iu
.ti \\n(INu
.ie !\\n()Iu+\\n()Ru-\w\\*(]Xu-3p \{\\*(]X
.br\}
.el \\*(]X\h|\\n()Iu+\\n()Ru\c
.}f
..

.de FN
\fI\|\\$1\|\fP
..
.SH "NAME"
aasm - advanced assembler

.SH "SYNOPSIS"
.BI "aasm [" options "] [" input-file " ... | " - " ] "

.SH "DESCRIPTION"
.B 

\fBaasm\fR is an advanced assembler designed to support several target
architectures. It has been designed to be easily extended and, should
be considered as a good alternative to monolithic assembler
development for each new target CPUs and binary file formats.

\fBaasm\fR should make assembly programming easier for developer, by
providing a set of advanced features: symbol scopes, expressions
engine, big integer support, numerous and accurate warning messages,
filter modules... Its dynamic modular architecture enables \fBaasm\fR
to extend its set of features with plug-ins.

This short manual describes the use of \fBaasm\fR with common input,
assembler and output modules. For a full list of features and more
help, please refer to the documentation. Some code examples given for
clarity are only valid when used with a specific set of modules and
should not be considered as generic examples for the whole
.B aasm
project.

.SH "OPTIONS"

.TP
.B -h, --help
Displays a short help message

.TP
.B -v, --version
Displays version info

.TP
.B --instr-help
Displays instruction quick help. this option should be used with the
instruction name as parameter. The request will be processed using the
loaded assembler module.

.TP
.B --color
Enables coloured output. Coloured output will remain disabled if stdin
and stderr aren't binded to a tty device.

.TP
.B -Wmore, --warning-more
Enables more warning messages.

.TP
.B -Wopt, --warning-optim
Enables optimisation warning messages. Most optimization messages are
generated by assembler and optional filter modules.

.TP
.B -Wctrl, --warning-ctrl
Enables control flow warning messages. Control flow messages are
generated when using optional filter modules.

.TP
.B -Wall, --warning-all
Enables all warning messages.

.TP
.B -Wnone, --warning-none
Disables all warning messages

.TP
.B -D, --define
Defines a symbol on the command line. This option need a valid symbol
name as parameter. The new symbol will be assigned an expression with
a null numerical value. Symbol will be defined for all source files on
then command line.

.TP
.B -g, --debug
Enables debug flag. This debug flag may be used by modules to add
debug informations in the current object file.

.TP
.B -ml, --module-list
Displays available module list.

.TP
.B -m, --module
Preloads an input, assembler, filter or output module. This option
need a valid module name as parameter.

.br
.SH SOURCE FILE

This section will describe the common source file layout recognised
when using the default Intel syntax parser as input module. This is a
quick start help section; refer to Intel syntax parser documentation
for more information.

The parser read input source data from file or standard input line at
once. Lines beginning with
.B `.'
are considered as directives, other lines are considered as
instructions or labels lines.  User defined macro instruction lines
should begin with the special
.B `@'
character.  Comments can be introduced in source file using the
.B `;'
character.

Labels have to be declared with a colon
.B `:'
character following the label name. Text following the label
declaration is parsed as a new line and can contain other label
declaration, instruction and directive.  Label declaration can also be
done using the
.B .label
directive; this enable use of label qualifier not supported with the simple
.B `label:'
form.

; AASM source file layout example

 .section code .text    ; section declaration directive

   .macro m             ; macro declaration directive
     mov eax, 1         ; instruction
   .endm

   lbl:                 ; simple label
   @m                   ; macro use

   lbl2: nop            ; label with instruction

   .label lbl_end       ; simple label

   ret                  ; instruction

 .ends

.SH DIRECTIVES

Here is a list of available directives with short description:

.TP 
.BI ".align ( offset | boundary ) " expression
Specify the current offset of next instruction or next instruction
alignment. this directive acts as ORG and ALIGN directives found in
most assemblers.
.I expression
must be defined before use of the directive and should reduce to a
numerical value.

.TP 
.BI ".db " value " [ , " value " [ , ... ] ] "
Dump one or more bytes in the current section. This directive only
support numerical values and is processed quickly by aasm. Use
.B .dump
for full expression and relocation support.

.TP 
.B .debug
Enables debug flag. This debug flag may be used by modules to add
debug informations in the current object file. This directive acts as
the
.B -g
command line parameter for the current object file.
.br

.TP 
.BI ".define " name " " expression
Define a symbol in current scope and assign an expression to the new
symbol. See the EXPRESSION section below. Defined expression can
contain
.B `$n'
positional parameters tokens where
.B n
is a decimal number. First positional parameter is
.B `$0'

.TP 
.BI ".dump " expression
Dump value of the given expression in the current section. Size of the
value in bytes depends of the expression size attribute. Expression
with undefined size are rejected with an error message. Size operator
priority must be considered when specifying size of the whole
expression: use
.B .dump word (a + b)
rather than
.B .dump word a + b.
Endian mode used depends on the loaded assembler module to match
target CPU endian.

.TP 
.B .endif
End conditional block started with
.B .if
directives family

.TP 
.B .else
Invert conditional state in block started with
.B .if
directives family. Several
.B .else
directives can be used before using
.B .endif
.

.TP 
.B .endm
End a macro previously started with the
.B .macro
directive.

.TP 
.BI .ends
End a section previously started with the
.B .section
directive.

.TP 
.B .endp
End a procedure previously started with the
.B .proc
directive.

.TP
.BI ".error " message
Add an error message.

.TP 
.BI ".export " name
Set the `export' flag for the
.I name
symbol. Output module may use this to mark symbol as exported or
global.

.TP 
.BI ".extern " name
Define a symbol in current scope and assign an external reference
.I name
to the new symbol. Multiple definitions of the same extern symbol in
the current scope are allowed.

.TP
.BI ".fill " value " " size
Dump several bytes with the same value in current section.
.I value
should be a numerical value and
.I size
can be an expression.
.I size
must be defined before use of the directive and should reduce to a
numerical value.

.TP 
.BI ".ifdef " name
Skip all following line in source input up to next
.B .else
or
.B .endif
directive if symbol name has not been defined BEFORE.

.TP 
.BI ".ifndef " name
Skip all following line in source input up to next
.B .else
or
.B .endif
directive if symbol name has been defined BEFORE.

.TP 
.BI ".include " filename
Include source file in current file.

.TP 
.BI ".label " name " [ " qualifier " ] "
Define a symbol in current scope and assign a code location to the new
symbol. An optional qualifier can be specified to help assembler and
modules understanding code behaviour. Valid qualifier are:
.B data
,
.B loop
,
.B call
,
.B taken
and
.B nottaken 

.TP 
.BI ".macro " name " [ " param1 " , " ... " ]"
Define a new symbol in current scope and assign an instruction list to
the new symbol.  A new symbol scope is opened over current scope and
all macro parameters are defined as special symbols in the new scope.
Aasm macro are not processed during a preprocessing stage because
there is no preprocessing stage, that's why parameters are considered
as true expressions (not as strings).  Macro can be used before being
defined as for all other symbol types. Macro should be ended using the
.B .endm
directive.

.TP 
.BI ".mod_out [ " params ...  " " ]
Output module directive. see module documentation for more
informations.

.TP 
.BI ".mod_asm [ " params ...  " " ]
Assembler module directive. see module documentation for more
informations.

.TP
.BI ".mod_load " name
Use module
.I name
for processing of the current object file. The module is loaded if
needed. This directive must be used before module is locked by the
assembling process.

.TP 
.BI ".obj_base " expression
Set object base address.
.I expression
must be defined before use of the directive and should reduce to a
numerical value.

.TP
.BI ".obj_name, .obj_desc, .obj_copyright " text
Set object name, description and copyright notice.

.TP
.BI ".pad " value " " size
Dump several bytes with the same value in current section to extend
previously dumped data size to
.I size
bytes. This directive must follow an other data directive as
.I .string
or
.I .db
, ...
.I value
should be a numerical value and
.I size
can be an expression.
.I size
must be defined before use of the directive and should reduce to a
numerical value.

.TP 
.BI ".proc " name
Define a new symbol in current scope and assign a code location to the
new symbol. The new symbol is marked as being a procedure (function)
rather than a simple label. A new symbol scope is opened over current
section scope. Procedure can be ended using the
.B .endp
directive.

.TP
.BI ".reserve " size
Reserve several uninitialized bytes in the current BSS section.
.I size
have to be an expression and must be defined before use of the
directive and should reduce to a numerical value.

.TP 
.BI ".section " type " [ " .name " ]"
Add a new section to current object file and open a new symbol scope
over global scope. A new section have to be defined before any
instruction line can be used.  Valid section types are:
.B code
,
.B data
,
.B wrcode
,
.B rodata
and
.B bss.
Section can be ended using the
.B .ends
directive.

.BI ".section_base, .section_align " expression
Set section base address and alignment.
.I expression
must be defined before use of the directive and should reduce to a
numerical value.

.TP 
.BI ".string [ " name " ] """string """"
Dump a character string in the current section.  A new label symbol
associated with string location will be created if
.I name
is specified.
.I string
can contain C like escaping sequences.

.TP
.BI ".warning " message
Add a warning message.

.SH "SYMBOLS & SCOPES"

Aasm store symbols list and instructions in scopes. Scopes are nested
data structures

Symbols are used by aasm to associate data objects commonly used in
assembly programs with a convenient name for the programmer.  They are
used to represent labels, procedures, defined expressions, external
references, macro parameters and macros.  Symbols can be defined using
directives (see the DIRECTIVES section) or command line options.

Each symbol exist in a given scope and have an unique name in this
scope. Redefinition of an already existing symbol in the current scope
will generate an error message. If the already defined symbol is not
located in the same scope, the new definition will shadow the old one.

In most cases, all symbols (labels, expressions, macro ...) can be
used before being defined. This is not true for expressions used with
some directives.
.B .ifdef
and
.B .ifndef
directives test symbol names defined before in the source input.
.B .align
,
.B .fill
,
.B .obj_base
,
.B .pad
,
.B .section_base
and
.B .section_align
directives need expressions than can be directly reduced to a
numerical value.

.br
.SH "EXPRESSIONS"

Aasm extensively use expressions during the assembling
process. Expressions are stored in an abstract syntax tree form and
can be reused in other expressions, computed and reduced. Size prefix
.B `byte'
,
.B `word'
, ... and memory access
.B `[ ]'
are considered as operators and can be part of any expression.

Expressions used with aasm can contains six token types:

.TP
.B Numerical values
Numerical values recognised by the Intel syntax parser module are C
like values. Decimal values should begin with
.B `1-9'
digits and octal values with the
.B `0'
digit. Hexadecimal and binary values have to be prefixed with
.B `0x'
and
.B `0b'
\ . Simple quoted strings can be used as numerical values in
expressions (example:
.B 'AB'
is the same as
.B 0x6162
).

.TP
.B Symbol names
They are used in expression to refer to labels and procedures, other
expressions defined with the
.B .define
directive, external references and macro parameters. Symbol names
should begin with
.B `a-z'
, 
.B `A-Z'
or
.B `_'
characters and may also contain
.B `0-9'
digits. When used to refer to a symbol defined in a different section,
the symbol name have to be prefixed by the section name using the
colon character (example:
.B .data:foo
). Macro symbols can not be used in expressions.

.TP
.B Section names
Used to refer to a section in expression. Section names should begin
with a
.B `.'
character.

.TP
.B Register names
Register names are recognised by the parser module using the assembler
module. CPU register are special token in expressions and are not
symbols.
.TP
.B Operators
Aasm expressions are made of binary and unary operators which can be
classified in the following categories: priority override
.B `( )'
, memory access
.B `[ ]'
, size
.B `byte' `word' `dword' `fword' `qword' `tword' `oword'
, arithmetic
.B `pow' `*' `/' `div' `%' `mod' `+' `-'
unary
.B `+' `-'
and logical operations
.B `shl' `shr' `&' `and' `^' `xor' `|' `or' `not' `~'
\ . Some operators have both, a short and a literal form.

.TP
.B Positional parameters
Positional parameters
.B `$n'
can only be used when the expression is defined using the
.B .define
directive. Expression must then be used with enough parameters to
allow sub definition of each
.B `$n'
positional parameters. To specify parameters to use with an
expression,
.B `(' `)'
characters containing
.B `,'
separated parameters list should be appended to the expression symbol
name.

.P

Aasm expression engine is able to perform simple reductions and
evaluations on expressions. More reductions may be supported in the
future. Here are some examples of working expression reductions:

 mov eax * 1, (ecx - ecx) * (esi - 2)    ; reduced to mov eax, 0
.br
 mov eax, [1 + eax - 3 + ebx + 1]        ; reduced to mov eax, [eax + ebx - 1]

.P

Positional parameters can be used as shown in the example below:

 .define A    eax + $0

 mov eax, [A(10) + 5]                    ; reduced to mov eax, [eax + 15]

.SH "INSTRUCTIONS"

As register names, instruction names are recognised by the loaded
assembler module. Operands order also depends on the assembler
module. A valid instruction line is made of the instruction name
followed by its operands.

Once built from instruction line, operand expressions should be
recognised later as valid for the current instruction by the assembler
module.  Non regular operand expressions may not be rejected by the
assembler module but added to the relocation list in the hope that it
will be reduced later or handled as output file relocations.

The instruction format recognised by the parser is Intel syntax style.
Instruction operands are expressions, refer to the EXPRESSIONS section
for more details. Here is a list of instruction syntax examples when
the x86 assembler module is used:

; set eax register to immediate value 1
.br
mov eax, 1

; set eax register to value at memory address 1
.br
mov eax, [1]

; set eax register to value at address pointed to by ebx register
.br
mov eax, [ebx]

; use of complex memory addressing
.br
mov eax, [ebx + byte 4]
.br
mov eax, [ebx + edx * 2 + 4]

; use of size prefix
.br
mov [esi], byte 0xaa
.br
mov word [esi], 0xaa
.br
add eax, byte 5

See
.B aasm-asm-*
(1) and other man pages for CPUs and assembler modules specific informations.

.SH "BUGS"

If you find a bug in \fBaasm\fR, you should report it. But first, you
have to make sure that it's real bug, and has not been corrected in
the last CVS version.

Before reporting problems concerning aasm core or base modules, check
other used modules and report bugs to the respective author.

All comments and bug reports concerning aasm should be done on the
project home page.

.SH "SEE ALSO"

Project home page:

.I http://savannah.nongnu.org/projects/aasm

Consider using the following mailing lists:

.I aasm-devel@nongnu.org
.br
.I aasm-users@nongnu.org

.br
.SH "AUTHORS"

Alexandre Becoulet,
.br
.I alexandre.becoulet@free.fr

Cedric Bail,
.br
.I cedric.bail@free.fr

Thanks to Baptiste Ancey, Matthieu Bernard, Maxime Bizon, Lionel
Bouchpan-Lerust-Juery for help on the initial release.

